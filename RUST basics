Basics of the programming language RUST. 
---
The basics, including the installation, how to write the hello world program, and some basic commands to use cargo.
Implementation of the guessing game in Rust using cargo. 

Some important cargo commands:

cargo new program_name – to create a new cargo project

cargo build – to compile create an executable file in another directory

cargo run – to compile the project and run the executable

cargo check – to check the rust program for compilation errors without actually creating the executable 
---
Variables and mutability.  
keywords: 
let - to declare a variable (def: immutable)
let mut - mutable variable
const - to declare constants. must specify type annotation.

Shadowing of variables - allows reuse of variable names and type conversions (unlike mutable variables)
---
Datatypes in Rust. 
Data types can be classified into scalars and compounds. 
Under scalars, we have integer types, floating-point types, Boolean types, and character types. We also looked at some arithmetic operations.  
Under compound types, we have a tuple type and arrays. 
Arrays have a fixed length unlike vectors. 
We also looked at the various annotations for these different types.
---
Functions:
Type must be specified with every function parameter.
Expressions vs statements: Expressions don't end with a semi-colon (results in mismatched types error). 
eg. {
    let x = 3;
    x + 1
}
Return type is specified using ->
eg. fn five() -> i32 {
    5
}
---
Comments: // for single line comments
---
Control flow:

if-else syntax:
if condition {
        ...
    } else {
        ...
    }

loops syntax: 
1. loop 
loop {
        ...
        break;
    } 
2. while
while condition {
        ...
    }
3. for
for number in range {
       ...
    }
---

Ownership:
heap vs stack: accessing heap data is slow while stack data can be accessed quickly
ownership is required for managing heap data.
ownership rules:
-Each value in Rust has a variable that’s called its owner.
-There can only be one owner at a time.
-When the owner goes out of scope, the value will be dropped.
Scope is the range within a program for which an item is valid.

Strings: 2 types: string literals and String (stored in heap)
You can create a String from a string literal using the from function. eg. let s = String::from("hello");
When a variable goes out of scope, Rust calls a special function called drop. Rust calls drop automatically at the closing curly bracket.
A string losses its scope once it is passed to a function. If a variable is assigned to the return value of a function, the ownership gets transferred to the variable.
A variable that includes data on the heap goes out of scope, the value will be cleaned up by drop unless the data has been moved to be owned by another variable

Shallow copying/move - older variable becomes invalidated
Deep copy - clone() for heap data (expensive)
for stack-only data- Copy trait is inexpensive and older variable is still valid
---
References and Borrowing

References - to access variable value without taking ownership
Borrowing - references as function parameters
Syntax - &(referencing) and *(dereferencing)
Mutable References - &mut s;
At any given time, you can have either one mutable reference or any number of immutable references.
References must always be valid.

Dangling references – pointers to location in memory that has been reassigned.

The slice type
String slices – reference to part of a string with data type &str
String literals are also slices.
String literals can be passed as function parameters.
Other Slices such as those for array are also possible.
Eg. array a = [1, 2, 3, 4, 5];
let slice = &a[1..3]; (type &[i32])

---
Structs
Initialization-
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
Instantiation-
let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    
Can be done using other struct instances as well
Tuple structs - struct Point(i32, i32, i32);
let origin = Point(0, 0, 0);

Ownership of Struct data - Structs use owned data types like String (cant use &str)
Printing structs - use {:?} or {:#?} in print statement along with #[derive(Debug)] just before the struct definition
Method Syntax - Methods are like functions but they are defined within the context of the struct 
impl Struct block eg. rect1.area() 
Associated functions don’t take self as a parameter eg. String::from
---
